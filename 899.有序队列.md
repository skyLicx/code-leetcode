**方法一：分情况讨论**
计算字典序最小的字符串时，需要分别考虑 $k=1$ 和 $k>1$ 的两种情况。
当 $k=1$ 时，每次只能取 $s$ 的首个字符并将其移动到末尾，因此对于给定的字符串，可能的移动方法是 唯一的，移动后的结果也是唯一的。对于长度为 $n$ 的字符串 $s$ ，经过 0 次到 $n-1$ 次移动之后分别得到 $n$ 个字符串，这 $n$ 个字符串中的字典序最小的字符串即为答案。
当 $k>1$ 时，一定可以经过移动将 $s$ 变成升序字符串，因此将字符串 $s$ 升序排序之后得到的字符串即为 答案。理由如下。
考虑 $k=2$ 的情况。假设 $s$ 的所有字符按照升序排序依次是 $c_{0}, c_{1}, \ldots, c_{n-1}$ 。对于 $s$ 的任意排列，总是 可以经过若干次移动将 $c_{n-1}$ 变成首个字符。
当 $c_{n-1}$ 变成首个字符之后，可以将 $c_{n-2}, c_{n-1}$ 变成前两个字符:

1. 每次将首个字符移动到末尾，直到 $c_{n-2}$ 变成首个字符；
2. 保持 $c_{n-2}$ 位于首个字符，每次将 $c_{n-2}$ 后面的字符移动到末尾，直到 $c_{n-2}$ 后面的字符是 $c_{n-1}$ 。
  使用同样的方法，对于 $1 \leq m<n$ ，如果 $c_{n-m}, c_{n-m+1}, \ldots, c_{n-1}$ 位于前 $m$ 个字符，则可以经过若干 次移动将 $c_{n-m-1}, c_{n-m}, c_{n-m+1}, \ldots, c_{n-1}$ 变成前 $m+1$ 个字符:

1. 每次将首个字符移动到末尾，直到 $c_{n-m-1}$ 变成首个字符，此时 $c_{n-m}, c_{n-m+1}, \ldots, c_{n-1}$ 为字符 串中连续的 $m$ 个字符；
2. 保持 $c_{n-m-1}$ 位于首个字符，每次将 $c_{n-m-1}$ 后面的字符移动到末尾，直到 $c_{n-m-1}$ 后面的字符 是 $c_{n-m}$ ，此时前 $m+1$ 个字符是 $c_{n-m-1}, c_{n-m}, c_{n-m+1}, \ldots, c_{n-1}$ 。
  因此，当 $k=2$ 时，一定可以经过移动将 $s$ 变成升序字符串。
  当 $k>2$ 时，同样可以对字符串的前两个字符执行移动操作将 $s$ 变成升序字符串。

```js
var orderlyQueue = function(s, k) {
    if (k === 1) {
        let ans = s;
        for (let i = 0; i < s.length - 1; ++i) {
            const n = s.length;
            s = s.substring(1, n) + s[0];
            ans = ans < s ? ans : s;
        }
        return ans;
    }
    return [...s].sort().join('');
};
```

